<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stickfigure Cyclist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(to bottom, #87CEEB 0%, #f0f0f0 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; 
            width: 100vw;
            position: relative;
        }
        
        #gameContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw; 
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        #gameCanvas {
            border: 3px solid #222;
            background: linear-gradient(to bottom, #87CEEB 0%, #f5f5f5 70%);
            box-shadow: 0 15px 50px rgba(0,0,0,0.3);
            cursor: pointer;
            width: min(calc(98vh * 2), 98vw);
            height: min(calc(98vw / 2), 98vh);
            aspect-ratio: 2 / 1;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #222;
            font-weight: bold;
            font-size: 20px;
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        @media (max-width: 600px) {
            #ui {
                top: 0;
                font-size: 14px;
                gap: 5px;
            }
            .stat {
                padding: 5px 10px;
            }
            .stat-value {
                font-size: 18px;
            }
        }
        .stat {
            background: rgba(255,255,255,0.9);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        .stat-value {
            font-size: 24px;
            color: #222;
        }
        #startScreen, #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255,255,255,0.95);
            padding: 50px;
            border-radius: 15px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.4);
            z-index: 20;
            max-width: 90%;
            cursor: pointer; 
        }
        #startScreen h1, #gameOver h1 {
            font-size: clamp(30px, 8vw, 56px);
            margin-bottom: 20px;
            color: #222;
            text-shadow: 3px 3px 0 #4285F4;
        }
        #startScreen p, #gameOver p {
            font-size: clamp(14px, 4vw, 18px);
            color: #666;
            margin: 10px 0;
        }
        .controls {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: clamp(14px, 4vw, 16px);
            text-align: left;
            display: inline-block;
        }
        .controls div {
            margin: 5px 0;
        }
        .blink {
            animation: blink 1s infinite;
            color: #DB4437;
            font-weight: bold;
            font-size: clamp(18px, 6vw, 22px);
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        #gameOver {
            display: none;
        }
        .medal {
            font-size: 48px;
            margin: 10px 0;
        }
        .gun-status {
            color: #DB4437;
            font-weight: bold;
            font-size: 18px;
            margin-top: 5px;
            display: none;
        }

        #mobileControls {
            position: fixed;
            bottom: 2vh;
            width: 100vw;
            max-width: 1000px;
            z-index: 30;
            padding: 0 20px;
            pointer-events: none;
            display: none;
        }
        .control-group {
            position: absolute;
            pointer-events: all;
        }
        #leftControls {
            left: 20px;
            bottom: 0;
            display: flex;
            gap: 10px;
        }
        #rightControls {
            right: 20px;
            bottom: 0;
            display: flex;
            gap: 10px;
        }
        .mobile-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 3px solid white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background 0.1s;
            touch-action: manipulation;
        }
        .mobile-button:active {
            background: rgba(0, 0, 0, 0.8);
            border-color: #F4B400;
        }
        #jumpButton {
            background: rgba(66, 133, 244, 0.7);
        }
        #jumpButton:active {
            background: rgba(66, 133, 244, 1.0);
        }
        #shootButton {
            background: rgba(219, 68, 55, 0.7);
        }
        #shootButton:active {
            background: rgba(219, 68, 55, 1.0);
        }
        #duckButton {
            background: rgba(15, 157, 88, 0.7);
        }
        #duckButton:active {
            background: rgba(15, 157, 88, 1.0);
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat">
            <div class="stat-label">DISTANCE</div>
            <div class="stat-value" id="distance">0m</div>
        </div>
        <div class="stat">
            <div class="stat-label">COINS</div>
            <div class="stat-value" id="coinCount">0</div>
        </div>
        <div class="stat">
            <div class="stat-label">BEST</div>
            <div class="stat-value" id="bestDistanceUI">0m</div>
        </div>
    </div>
    <div id="gunUI" class="stat gun-status">
        <div class="stat-label">GUN</div>
        <div class="stat-value" id="bulletCountUI"></div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="500"></canvas>
    </div>
    
    <div id="startScreen">
        <h1>üö¥ CYCLIST</h1>
        <p>A faster start! Challenge begins after 3000m!</p>
        <div class="controls">
            <h3>üñ•Ô∏è COMPUTER CONTROLS</h3>
            <div><strong>SPACE / CLICK</strong> = Jump / Double Jump (Hold for Higher)</div>
            <div><strong>DOWN ARROW / S</strong> = Duck</div>
            <div style="margin-top: 10px; color: #DB4437;">
                <strong>LEFT ARROW / A</strong> = Shoot (if gun active)
            </div>
            <hr style="margin: 10px 0;">
            <h3>üì± MOBILE CONTROLS</h3>
            <div>**RIGHT BUTTON** (Tap/Hold) = Jump / Double Jump</div>
            <div>**LEFT UP BUTTON** = Shoot (if gun active)</div>
            <div>**LEFT DOWN BUTTON** = Duck (Hold)</div>
            <div style="margin-top: 5px; color: #F4B400;">
                Collect <strong>3 Coins</strong> for 3 Bullets!
            </div>
        </div>
        <p class="blink">‚ñ∂ CLICK/TAP TO START ‚óÄ</p>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <div class="medal" id="medal"></div>
        <p style="font-size: 24px; color: #222; margin: 15px 0;">
            Distance: <strong id="finalDistance">0m</strong>
        </p>
        <p id="newRecord" style="color: #4285F4; font-weight: bold; font-size: 20px; display: none;">
            üèÜ NEW RECORD! üèÜ
        </p>
        <p class="blink">CLICK/TAP TO RESTART</p>
    </div>

    <div id="mobileControls">
        <div id="leftControls" class="control-group">
            <div class="mobile-button" id="shootButton">üî´</div>
            <div class="mobile-button" id="duckButton">‚¨áÔ∏è</div>
        </div>
        <div id="rightControls" class="control-group">
            <div class="mobile-button" id="jumpButton">‚¨ÜÔ∏è</div>
        </div>
    </div>

    <audio id="audioJump" preload="auto">
        <source src="https://opengameart.org/sites/default/files/Sproing_0.ogg" type="audio/ogg">
        <source src="https://opengameart.org/sites/default/files/Sproing_0.mp3" type="audio/mpeg">
    </audio>

    <audio id="audioGameOver" preload="auto">
        <source src="https://opengameart.org/sites/default/files/mixkit-arcade-retro-game-over-213.wav" type="audio/wav">
        <source src="https://opengameart.org/sites/default/files/mixkit-arcade-retro-game-over-213.mp3" type="audio/mpeg">
    </audio>

    <audio id="audioCycling" preload="auto" loop>
        <source src="https://opengameart.org/sites/default/files/soft_whoosh.wav" type="audio/wav">
        <source src="https://opengameart.org/sites/default/files/soft_whoosh.mp3" type="audio/mpeg">
    </audio>

    <audio id="audioCoin" preload="auto">
        <source src="https://opengameart.org/sites/default/files/5.wav" type="audio/wav">
        <source src="https://opengameart.org/sites/default/files/5.mp3" type="audio/mpeg">
    </audio>

    <audio id="audioShoot" preload="auto">
        <source src="https://opengameart.org/sites/default/files/laser2.ogg" type="audio/ogg">
        <source src="https://opengameart.org/sites/default/files/laser2.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOver');
        const mobileControls = document.getElementById('mobileControls');

        // --- CONSTANTS ---
        const GOOGLE_BLUE = '#4285F4';
        const GOOGLE_RED = '#DB4437';
        const GOOGLE_YELLOW = '#F4B400';
        const GOOGLE_GREEN = '#0F9D58';
        const GOOGLE_PURPLE = '#673AB7'; 
        const COIN_COLOR = GOOGLE_YELLOW;
        const BULLET_COLOR = '#444';

        // Physics Tweaks
        const SMOOTH_GRAVITY = 0.65; 
        const MAX_CHARGE_TIME = 25; 
        const JUMP_POWER_NORMAL = -13;
        const JUMP_POWER_MAX = -17; 

        // Game Rules
        const DOUBLE_JUMP_START_DISTANCE = 400;
        const ROLLING_OBSTACLE_START_DISTANCE = 500;
        
        // Speed Definitions
        const SLOW_START_SPEED = 7.0; 
        const CHALLENGE_SPEED = 8.5; 
        const EASY_SPEED_INCREASE_RATE = 400; 
        const CHALLENGE_SPEED_INCREASE_RATE = 150; 
        const CHALLENGE_START_DISTANCE = 3000; 

        // Obstacle Spawning
        const OBSTACLE_CHANCE_WEIGHT = 0.85; 
        const COIN_CHANCE_WEIGHT = 0.15; 
        const BASE_MIN_GAP_FRAMES = 70; 
        const BASE_MAX_GAP_FRAMES = 100; 
        const GAP_REDUCTION_FACTOR = 5; 
        
        // Monetization
        const COINS_FOR_GUN = 3; 
        const STARTING_BULLETS = 3;

        // --- AUDIO SETUP ---
        let audioCtx = null;

        function initAudioContext() {
            if (!audioCtx) {
                const AC = window.AudioContext || window.webkitAudioContext;
                if (AC) audioCtx = new AC();
            }
        }

        function unlockAudio() {
            initAudioContext();
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
            document.removeEventListener('touchstart', unlockAudio);
            document.removeEventListener('mousedown', unlockAudio);
        }
        document.addEventListener('touchstart', unlockAudio, {passive: true});
        document.addEventListener('mousedown', unlockAudio);

        const JUMP_SYNTH_GAIN = 0.30;
        const JUMP_HTML_VOLUME = 1.00;

        function playSynthTone(frequency, duration = 0.12, type = 'sine', when = 0, gainLevel = 0.12) {
            try {
                if (!audioCtx) return;
                const now = audioCtx.currentTime + when;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(frequency, now);

                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.exponentialRampToValueAtTime(gainLevel, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(now);
                osc.stop(now + duration + 0.02);
            } catch (e) {}
        }

        function playJumpSound() {
            initAudioContext();
            if (audioCtx) {
                playSynthTone(800 + Math.random() * 120, 0.09, 'sine', 0, JUMP_SYNTH_GAIN);
                playSynthTone(520 + Math.random() * 80, 0.12, 'triangle', 0.02, JUMP_SYNTH_GAIN * 0.85);
                return;
            }
            const htmlJump = document.getElementById('audioJump');
            if (htmlJump) {
                try {
                    htmlJump.currentTime = 0;
                    htmlJump.volume = JUMP_HTML_VOLUME;
                    htmlJump.play().catch(() => {});
                } catch (e) {}
            }
        }

        function playGameOverSound() {
            initAudioContext();
            if (audioCtx) {
                playSynthTone(380, 0.28, 'sawtooth', 0, 0.14);
                playSynthTone(280, 0.28, 'sawtooth', 0.28, 0.12);
                playSynthTone(200, 0.28, 'sine', 0.56, 0.10);
                return;
            }
            const htmlGO = document.getElementById('audioGameOver');
            if (htmlGO) {
                try {
                    htmlGO.currentTime = 0;
                    htmlGO.volume = 0.8;
                    htmlGO.play().catch(() => {});
                } catch (e) {}
            }
        }

        const cyclingSound = document.getElementById('audioCycling');
        if (cyclingSound) { cyclingSound.volume = 0.15; cyclingSound.loop = true; }
        const coinSound = document.getElementById('audioCoin');
        if (coinSound) coinSound.volume = 0.2;
        const shootSound = document.getElementById('audioShoot');
        if (shootSound) shootSound.volume = 0.4;

        // --- GAME STATE ---
        let gameState = {
            started: false,
            playing: false,
            distance: 0,
            bestDistance: parseInt(localStorage.getItem('bestDistance')) || 0,
            gameSpeed: SLOW_START_SPEED, 
            baseSpeed: SLOW_START_SPEED, 
            gravity: SMOOTH_GRAVITY, 
            obstacles: [],
            coins: [], 
            bullets: [], 
            particles: [],
            groundY: 400,
            speedMode: 'easy',
            speedFrameCounter: 0,
            cyclingSoundPlaying: false,
        };
        
        document.getElementById('bestDistanceUI').textContent = gameState.bestDistance + 'm';

        let player = {
            x: 120,
            y: gameState.groundY - 30,
            yOffset: 0,
            vy: 0,
            jumpPower: JUMP_POWER_NORMAL,
            maxJumpPower: JUMP_POWER_MAX,
            width: 40,
            height: 30,
            rotation: 0,
            isJumping: false,
            isDucking: false,
            isCharging: false,
            chargeTime: 0,
            onGround: true,
            jumpQueued: false,
            jumpsRemaining: 2,
            coinCount: 0,
            gunEnabled: false,
            bulletCount: 0,
            previousOnGround: true, 
        };
        
        let keys = {};
        let frameCount = 0;
        let nextSpawnTime = 0;

        // --- MOBILE INPUT STATES ---
        let mobileJumpActive = false;
        let mobileDuckActive = false;
        let mobileShootTrigger = false;
        
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 15;
            }
            update() { this.x -= gameState.gameSpeed; }
            draw() {
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);

                ctx.fillStyle = COIN_COLOR;
                ctx.strokeStyle = GOOGLE_RED;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(drawX + this.width / 2, drawY + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = '#111';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('C', drawX + this.width / 2, drawY + this.height * 0.7);
            }
            checkCollision() {
                const effectivePlayerY = player.y + player.yOffset;
                return (player.x + 15 > this.x && player.x - 15 < this.x + this.width &&
                        effectivePlayerY + 5 > this.y && effectivePlayerY - 30 < this.y + this.height);
            }
            isOffScreen() { return this.x + this.width < 0; }
        }
        
        class Bullet {
            constructor() {
                this.x = player.x + 10; 
                this.y = player.y + player.yOffset - 25; 
                this.width = 12;
                this.height = 4;
                this.vX = 25; 
                this.hit = false;
            }
            update() { this.x += this.vX; }
            draw() { 
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);
                ctx.fillStyle = BULLET_COLOR; 
                ctx.fillRect(drawX, drawY, this.width, this.height); 
            }
            isOffScreen() { return this.x > canvas.width; }
        }
        
        class Obstacle {
            constructor(type, x = canvas.width + 50) {
                this.x = x;
                this.type = type;
                this.vX = 0;

                // ‚úÖ explosion state (Chrome-safe delayed removal)
                this.exploding = false;
                this.explodeFrame = 0;
                this.remove = false;
                this.explosionSeed = Math.random() * 9999;
                
                if (type === 'low') {
                    this.width = 22 + Math.random() * 10; 
                    const heightVariation = Math.random();
                    if (heightVariation < 0.3) {
                        this.height = 30 + Math.random() * 25; 
                    } else if (heightVariation < 0.7) {
                        this.height = 55 + Math.random() * 30; 
                    } else {
                        this.height = 85 + Math.random() * 40; 
                    }
                    this.y = gameState.groundY - this.height;
                    this.color = GOOGLE_RED; 
                } else if (type === 'moving') {
                    this.width = 28 + Math.random() * 12;
                    this.height = 40 + Math.random() * 20;
                    this.baseY = gameState.groundY - 80 - Math.random() * 50; 
                    this.y = this.baseY;
                    this.amplitude = 25 + Math.random() * 35;
                    this.speed = 0.035 + Math.random() * 0.025;
                    this.phaseOffset = Math.random() * Math.PI * 2; 
                    this.color = GOOGLE_BLUE; 
                } else if (type === 'doubleJumpAnchor') {
                    this.width = 32; 
                    this.height = 22; 
                    this.y = gameState.groundY - this.height;
                    this.color = GOOGLE_GREEN; 
                } else if (type === 'doubleJumpPillar') {
                    this.width = 22; 
                    this.height = 140 + Math.random() * 40; 
                    this.y = gameState.groundY - this.height;
                    this.color = GOOGLE_PURPLE; 
                } else if (type === 'rolling') {
                    this.width = 35;
                    this.height = 35;
                    this.y = gameState.groundY - this.height;
                    this.color = GOOGLE_YELLOW; 
                    this.vX = (Math.random() > 0.5 ? -1 : 1) * (0.8 + Math.random() * 1.5); 
                    this.rotation = 0;
                }
            }

            update() {
                // ‚úÖ Explosion animation frames
                if (this.exploding) {
                    this.explodeFrame++;

                    // spawn extra particles during first few frames
                    if (this.explodeFrame <= 6) {
                        createParticles(this.x + this.width/2, this.y + this.height/2, GOOGLE_RED, 6);
                        createParticles(this.x + this.width/2, this.y + this.height/2, GOOGLE_YELLOW, 4);
                    }

                    if (this.explodeFrame > 14) {
                        this.remove = true; // delayed removal for Chrome reliability
                    }
                    return;
                }

                if (this.type === 'rolling') {
                    this.x -= (gameState.gameSpeed + this.vX); 
                } else {
                    this.x -= gameState.gameSpeed;
                }

                if (this.type === 'moving') {
                    this.y = this.baseY + Math.sin(frameCount * this.speed + this.phaseOffset) * this.amplitude;
                } else if (this.type === 'rolling') {
                    this.rotation += (gameState.gameSpeed + this.vX) * 0.035; 
                }
            }
            
            draw() {
                // ‚úÖ draw explosion ring instead of instant vanish
                if (this.exploding) {
                    const cx = this.x + this.width / 2;
                    const cy = this.y + this.height / 2;
                    const t = Math.min(1, this.explodeFrame / 14);
                    const radius = 10 + t * (this.width + 35);
                    ctx.save();
                    ctx.globalAlpha = 1 - t;
                    ctx.strokeStyle = GOOGLE_RED;
                    ctx.lineWidth = 5 - t * 3;
                    ctx.beginPath();
                    ctx.arc(Math.round(cx), Math.round(cy), radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = (1 - t) * 0.7;
                    ctx.strokeStyle = GOOGLE_YELLOW;
                    ctx.lineWidth = 3 - t * 2;
                    ctx.beginPath();
                    ctx.arc(Math.round(cx), Math.round(cy), radius * 0.65, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    return;
                }

                ctx.strokeStyle = '#111';
                ctx.lineWidth = 2;
                
                if (this.type === 'rolling') {
                    const centerX = Math.round(this.x) + this.width / 2; 
                    const centerY = Math.round(this.y) + this.height / 2; 
                    const radius = this.width / 2;

                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(this.rotation);
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-radius, 0); ctx.lineTo(radius, 0);
                    ctx.moveTo(0, -radius); ctx.lineTo(0, radius);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    const drawX = Math.round(this.x);
                    const drawY = Math.round(this.y);
                    
                    ctx.fillStyle = this.color;
                    ctx.fillRect(drawX, drawY, this.width, this.height);
                    ctx.strokeRect(drawX, drawY, this.width, this.height);
                }
            }

            isOffScreen() { return this.x + this.width < 0; }

            checkCollision() {
                if (this.exploding) return false; // ‚úÖ ignore exploding obstacles

                const effectivePlayerY = player.y + player.yOffset;
                let playerTop, playerBottom;

                if (player.isDucking) {
                    playerTop = effectivePlayerY - 5; 
                    playerBottom = effectivePlayerY + 5;
                } else {
                    playerTop = effectivePlayerY - 30;
                    playerBottom = effectivePlayerY + 5;
                }
                
                const playerLeft = player.x - 15;
                const playerRight = player.x + 15;
                const obsLeft = this.x;
                const obsRight = this.x + this.width;
                const obsTop = this.y;
                const obsBottom = this.y + this.height;

                return (playerRight > obsLeft && playerLeft < obsRight &&
                        playerBottom > obsTop && playerTop < obsBottom);
            }
            
            checkBulletCollision(bullet) {
                if (this.exploding) return false;
                const obsLeft = this.x;
                const obsRight = this.x + this.width;
                const obsTop = this.y;
                const obsBottom = this.y + this.height;
                return (bullet.x + bullet.width > obsLeft && bullet.x < obsRight &&
                        bullet.y + bullet.height > obsTop && bullet.y < obsBottom);
            }
        }

        function spawnObstacleOrCoin() {
            if (frameCount < nextSpawnTime) return;

            let initialX = canvas.width + 50; 
            const speedFactor = gameState.gameSpeed / SLOW_START_SPEED; 
            const minGap = Math.max(50, BASE_MIN_GAP_FRAMES - (speedFactor * GAP_REDUCTION_FACTOR)); 
            const maxGap = Math.max(80, BASE_MAX_GAP_FRAMES - (speedFactor * GAP_REDUCTION_FACTOR)); 
            const spawnRand = Math.random();
            let spawned = false;
            
            if (spawnRand < OBSTACLE_CHANCE_WEIGHT) { 
                const typeRand = Math.random();
                let type;
                if (gameState.distance > DOUBLE_JUMP_START_DISTANCE && typeRand < 0.1) {
                    type = 'doubleJumpPillarCombo';
                } else if (gameState.distance > ROLLING_OBSTACLE_START_DISTANCE && typeRand < 0.25) { 
                     type = 'rolling';
                } else if (typeRand < 0.65) {
                    type = 'low'; 
                } else {
                    type = 'moving';
                }
                
                if (type === 'doubleJumpPillarCombo') {
                    const firstObs = new Obstacle('doubleJumpAnchor', initialX);
                    gameState.obstacles.push(firstObs);
                    const PILLAR_GAP = 110; 
                    const secondObs = new Obstacle('doubleJumpPillar', firstObs.x + firstObs.width + PILLAR_GAP); 
                    gameState.obstacles.push(secondObs);
                    nextSpawnTime = frameCount + BASE_MAX_GAP_FRAMES * 3.5; 
                } else {
                    gameState.obstacles.push(new Obstacle(type, initialX));
                    nextSpawnTime = frameCount + minGap + Math.random() * (maxGap - minGap);
                }
                spawned = true;
            } 
            else if (spawnRand < OBSTACLE_CHANCE_WEIGHT + COIN_CHANCE_WEIGHT) { 
                const coinY = gameState.groundY - 50 - Math.random() * 100;
                gameState.coins.push(new Coin(initialX, coinY));
                nextSpawnTime = frameCount + minGap * 0.8 + Math.random() * (maxGap - minGap) * 0.5;
                spawned = true;
            }

            if (!spawned) nextSpawnTime = frameCount + 5;
        }

        function shoot() {
            if (!player.gunEnabled || player.bulletCount <= 0) return;
            player.bulletCount--;
            gameState.bullets.push(new Bullet());
            if (shootSound) {
                try { shootSound.currentTime = 0; shootSound.play().catch(() => {}); } catch (e) {}
            }
            if (player.bulletCount === 0) {
                player.gunEnabled = false;
                document.getElementById('gunUI').style.display = 'none';
            }
        }

        function handleShootInput() {
            if (gameState.playing) shoot();
        }
        
        function handleJumpInput() {
            if (!gameState.playing) return; 

            if (player.onGround && !player.isDucking) {
                player.isCharging = true;
                player.jumpQueued = false;
            } else if (!player.onGround && player.jumpsRemaining > 0 && !player.isDucking) {
                player.vy = player.jumpPower;
                player.isJumping = true;
                player.onGround = false;
                player.jumpsRemaining--; 
                player.isCharging = false;
                player.chargeTime = 0;
                createParticles(player.x, player.y - 20, GOOGLE_YELLOW, 8); 
                playJumpSound();
            } else if (player.isJumping && !player.isDucking) {
                player.jumpQueued = true;
            }
        }

        function releaseJump() {
            if (player.isCharging && player.onGround) {
                const chargeRatio = Math.min(player.chargeTime, MAX_CHARGE_TIME) / MAX_CHARGE_TIME;
                const jumpStrength = player.jumpPower + chargeRatio * (player.maxJumpPower - player.jumpPower); 
                
                player.vy = jumpStrength;
                player.isJumping = true;
                player.onGround = false;
                player.isCharging = false;
                player.chargeTime = 0;
                player.jumpQueued = false;
                player.jumpsRemaining--; 
                createParticles(player.x, player.y + 5, GOOGLE_BLUE, 5); 
                playJumpSound();
            }
            if (!player.isJumping) {
                player.isCharging = false;
                player.chargeTime = 0;
            }
        }

        function updatePlayer() {
            if (!gameState.playing) return;

            player.previousOnGround = player.onGround;

            if (player.isCharging) player.chargeTime++;

            const isInputDucking = keys['ArrowDown'] || keys['s'] || mobileDuckActive;
            const isInputShoot = keys['ArrowLeft'] || keys['a'] || mobileShootTrigger;

            if (isInputDucking && player.onGround) {
                player.isDucking = true;
                player.yOffset = 25;
            } else {
                player.isDucking = isInputDucking && !player.onGround;
                if (!isInputDucking || player.onGround) player.yOffset = 0; 
            }

            player.vy += gameState.gravity;
            player.y += player.vy;

            let groundLevel = gameState.groundY - 30;
            let landedOnAnchor = false;

            if (player.vy >= 0) { 
                gameState.obstacles.forEach(obs => {
                    if (obs.exploding) return;

                    if ((obs.type === 'low' || obs.type === 'doubleJumpAnchor') &&
                        player.x + 15 > obs.x && player.x - 15 < obs.x + obs.width &&
                        player.y + 5 >= obs.y && player.y + 5 < obs.y + obs.height) 
                    {
                        if (player.y + 5 <= obs.y + obs.height) {
                            groundLevel = Math.min(groundLevel, obs.y - 30); 
                            if (obs.type === 'doubleJumpAnchor') landedOnAnchor = true;
                        }
                    }
                });
            }

            if (player.y >= groundLevel) {
                const landingSpeed = Math.abs(player.vy);
                player.y = groundLevel;
                player.vy = 0;
                player.isJumping = false;
                player.onGround = true;
                
                if (player.y === gameState.groundY - 30 || landedOnAnchor) player.jumpsRemaining = 2; 
                
                if (player.jumpQueued) {
                    player.vy = player.jumpPower; 
                    player.isJumping = true;
                    player.onGround = false;
                    player.jumpQueued = false;
                    player.jumpsRemaining--; 
                }

                if (landingSpeed > 1) createParticles(player.x, player.y + 5, GOOGLE_GREEN, Math.floor(landingSpeed)); 
            } else {
                player.onGround = false;
            }

            if (player.onGround && !gameState.cyclingSoundPlaying) {
                 if (cyclingSound) { try { cyclingSound.currentTime = 0; cyclingSound.play().catch(() => {});} catch (e) {} }
                 gameState.cyclingSoundPlaying = true;
            } else if (!player.onGround && gameState.cyclingSoundPlaying) {
                if (cyclingSound) { try { cyclingSound.pause(); cyclingSound.currentTime = 0; } catch (e) {} }
                gameState.cyclingSoundPlaying = false;
            }

            if (!player.onGround) {
                if (player.isDucking) player.rotation = Math.PI / 3;
                else player.rotation = Math.min(Math.PI / 6, player.vy * 0.03);
            } else {
                player.rotation = 0;
            }
            
            if (isInputShoot && gameState.playing) {
                 handleShootInput();
                 keys['ArrowLeft'] = false; 
                 keys['a'] = false;
                 mobileShootTrigger = false;
            }
            
            gameState.coins = gameState.coins.filter(coin => {
                if (coin.checkCollision()) {
                    player.coinCount++;
                    if (coinSound) { try { coinSound.currentTime = 0; coinSound.play().catch(() => {}); } catch (e) {} }
                    
                    if (player.coinCount % COINS_FOR_GUN === 0) { 
                        player.gunEnabled = true;
                        player.bulletCount = STARTING_BULLETS;
                        document.getElementById('gunUI').style.display = 'block';
                    }
                    return false;
                }
                return true;
            });
            
            document.getElementById('coinCount').textContent = player.coinCount;
            document.getElementById('bulletCountUI').textContent = player.bulletCount + ' / ' + STARTING_BULLETS;
            
            if (mobileJumpActive) handleJumpInput(); 
            else releaseJump();
        }

        // ‚úÖ Chrome-safe + Explosion-safe collision handling
        function updateGame() {
            if (!gameState.playing) return;

            frameCount++; 
            gameState.speedFrameCounter++; 
            gameState.distance = Math.floor((frameCount * gameState.gameSpeed) / 10);

            if (gameState.distance >= CHALLENGE_START_DISTANCE && gameState.speedMode === 'easy') {
                gameState.speedMode = 'challenge';
                gameState.baseSpeed = CHALLENGE_SPEED;
                gameState.speedFrameCounter = 0; 
            }
            
            const increaseRate = gameState.speedMode === 'easy' ? EASY_SPEED_INCREASE_RATE : CHALLENGE_SPEED_INCREASE_RATE;
            gameState.gameSpeed = gameState.baseSpeed + gameState.speedFrameCounter / increaseRate;

            spawnObstacleOrCoin();

            // 1) update bullets first
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const b = gameState.bullets[i];
                b.update();
                if (b.isOffScreen()) {
                    gameState.bullets.splice(i, 1);
                }
            }

            // 2) update obstacles (movement / explosion frames)
            for (let j = gameState.obstacles.length - 1; j >= 0; j--) {
                const o = gameState.obstacles[j];
                o.update();
                if (o.isOffScreen() || o.remove) {
                    gameState.obstacles.splice(j, 1);
                }
            }

            // 3) bullet vs obstacle collision (backward loops = Chrome safe)
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                let bulletRemoved = false;

                for (let j = gameState.obstacles.length - 1; j >= 0; j--) {
                    const obs = gameState.obstacles[j];
                    if (obs.exploding) continue;

                    if (obs.checkBulletCollision(bullet)) {
                        // mark explosion (delayed removal)
                        obs.exploding = true;
                        obs.explodeFrame = 0;

                        // big first burst
                        createParticles(obs.x + obs.width/2, obs.y + obs.height/2, GOOGLE_RED, 20);
                        createParticles(obs.x + obs.width/2, obs.y + obs.height/2, GOOGLE_YELLOW, 10);

                        // remove bullet immediately
                        gameState.bullets.splice(i, 1);
                        bulletRemoved = true;
                        break;
                    }
                }

                if (bulletRemoved) continue;
            }

            // 4) player collision check (ignore exploding obstacles)
            for (let k = 0; k < gameState.obstacles.length; k++) {
                if (gameState.obstacles[k].checkCollision()) {
                    gameOver();
                    return;
                }
            }

            // coins
            gameState.coins.forEach(coin => coin.update());
            gameState.coins = gameState.coins.filter(coin => !coin.isOffScreen());

            // particles
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx - gameState.gameSpeed; 
                p.y += p.vy;
                p.vy += gameState.gravity * 0.7; 
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(Math.round(player.x), Math.round(player.y + player.yOffset)); 
            ctx.rotate(player.rotation);

            const scale = player.isDucking ? 0.7 : 1;
            ctx.scale(1, scale);

            if (player.isCharging) {
                ctx.strokeStyle = GOOGLE_RED; 
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 30 + (player.chargeTime / MAX_CHARGE_TIME) * 15, 0, Math.PI * 2); 
                ctx.stroke();
            }

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2.5;
            
            const wheelRotation = frameCount * gameState.gameSpeed * 0.08; 
            
            ctx.beginPath();
            ctx.arc(-15, 0, 10, 0, Math.PI * 2);
            ctx.stroke();
            for (let i = 0; i < 6; i++) {
                const angle = wheelRotation + (Math.PI / 3) * i;
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(-15 + Math.cos(angle) * 8, Math.sin(angle) * 8);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(15, 0, 10, 0, Math.PI * 2);
            ctx.stroke();
            for (let i = 0; i < 6; i++) {
                const angle = wheelRotation + (Math.PI / 3) * i;
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(15 + Math.cos(angle) * 8, Math.sin(angle) * 8);
                ctx.stroke();
            }

            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-15, 0); 
            ctx.lineTo(0, -15); 
            ctx.lineTo(15, 0); 
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, -15); 
            ctx.lineTo(-5, -15); 
            ctx.moveTo(15, 0);
            ctx.lineTo(15, -15); 
            ctx.lineTo(0, -15); 
            ctx.stroke();

            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(0, -15); 
            ctx.lineTo(0, -28); 
            ctx.stroke();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, -32, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            const animationAmplitude = player.onGround ? 0.2 : 0;
            const armAngle = player.onGround ? Math.sin(frameCount * gameState.gameSpeed * 0.01) * animationAmplitude : 0;
            ctx.beginPath();
            ctx.moveTo(0, -22);
            ctx.lineTo(-8 + Math.cos(armAngle) * 3, -18);
            ctx.moveTo(0, -22);
            ctx.lineTo(8 + Math.cos(armAngle) * 3, -18);
            ctx.stroke();

            const legAngle = player.onGround ? Math.sin(frameCount * gameState.gameSpeed * 0.02) * animationAmplitude * 3 : 0;
            ctx.beginPath();
            ctx.moveTo(0, -15); 
            ctx.lineTo(-5 + Math.cos(legAngle) * 8, -6 + Math.sin(legAngle) * 8); 
            ctx.moveTo(0, -15); 
            ctx.lineTo(5 + Math.cos(legAngle + Math.PI) * 8, -6 + Math.sin(legAngle + Math.PI) * 8); 
            ctx.stroke();
            
            if (player.gunEnabled) {
                ctx.fillStyle = BULLET_COLOR;
                ctx.fillRect(8, -25, 10, 5); 
                ctx.fillRect(18, -27, 8, 3); 
            }

            ctx.restore();
        }
        
        function drawGround() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, gameState.groundY);
            ctx.lineTo(canvas.width, gameState.groundY);
            ctx.stroke();
            
            ctx.fillStyle = GOOGLE_GREEN; 
            for (let i = 0; i < canvas.width; i += 30) {
                const offset = (frameCount * gameState.gameSpeed * 0.5) % 30;
                ctx.fillRect(Math.round(i - offset), gameState.groundY + 2, 15, 3);
            }
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const cloudOffset = (frameCount * gameState.gameSpeed * 0.2) % (canvas.width + 300);
            
            for (let i = 0; i < 5; i++) {
                const x = Math.round(i * 280 - cloudOffset); 
                const y = 50 + i * 25;
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.arc(x + 20, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 45, y, 25, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawClouds();
            drawGround();

            gameState.coins.forEach(coin => coin.draw());
            gameState.obstacles.forEach(obs => obs.draw());
            gameState.bullets.forEach(bullet => bullet.draw());

            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(Math.round(p.x), Math.round(p.y), p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            if (gameState.playing || gameState.started) drawPlayer();
            
            document.getElementById('distance').textContent = gameState.distance + 'm';
            document.getElementById('bestDistanceUI').textContent = gameState.bestDistance + 'm';
        }
        
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: -Math.random() * 4,
                    life: 1,
                    size: 1.5 + Math.random() * 2.5,
                    color: color || '#666'
                });
            }
        }

        function gameOver() {
            gameState.playing = false;
            createParticles(player.x, player.y, GOOGLE_RED, 20); 
            
            if (cyclingSound) { try { cyclingSound.pause(); cyclingSound.currentTime = 0; } catch (e) {} }
            gameState.cyclingSoundPlaying = false;
            
            playGameOverSound();
            
            const newRecord = gameState.distance > gameState.bestDistance;
            if (newRecord) {
                gameState.bestDistance = gameState.distance;
                localStorage.setItem('bestDistance', gameState.bestDistance);
                document.getElementById('newRecord').style.display = 'block';
            } else {
                document.getElementById('newRecord').style.display = 'none';
            }
            
            let medal = '';
            if (gameState.distance >= 10000) medal = 'üíé'; 
            else if (gameState.distance >= 5000) medal = 'ü•á'; 
            else if (gameState.distance >= 2500) medal = 'ü•à'; 
            else if (gameState.distance >= 1000) medal = 'ü•â'; 
            
            document.getElementById('medal').textContent = medal;
            document.getElementById('finalDistance').textContent = gameState.distance + 'm';
            gameOverScreen.style.display = 'block';
            mobileControls.style.display = 'none';
        }

        function startGame() {
            if (gameState.playing) return; 

            gameState.started = true;
            gameState.playing = true;
            gameState.distance = 0;
            gameState.gameSpeed = SLOW_START_SPEED; 
            gameState.baseSpeed = SLOW_START_SPEED; 
            gameState.speedMode = 'easy'; 
            gameState.gravity = SMOOTH_GRAVITY;
            gameState.obstacles = [];
            gameState.coins = [];
            gameState.bullets = [];
            gameState.particles = [];

            player.y = gameState.groundY - 30;
            player.yOffset = 0;
            player.vy = 0;
            player.isJumping = false;
            player.onGround = true;
            player.rotation = 0;
            player.isCharging = false;
            player.chargeTime = 0;
            player.jumpQueued = false;
            player.jumpsRemaining = 2;
            player.coinCount = 0;
            player.gunEnabled = false;
            player.bulletCount = 0;
            
            frameCount = 0;
            gameState.speedFrameCounter = 0;
            nextSpawnTime = 20; 
            
            document.getElementById('gunUI').style.display = 'none';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            document.getElementById('coinCount').textContent = player.coinCount;
            mobileControls.style.display = 'block';

            unlockAudio();

            if (player.onGround && cyclingSound) {
                try { cyclingSound.currentTime = 0; cyclingSound.play().catch(() => {}); } catch (e) {}
                gameState.cyclingSoundPlaying = true;
            }
        }

        function gameLoop() {
            if (gameState.playing) {
                updatePlayer();
                updateGame();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function handleStartOrJump(isPress) {
            if (!gameState.playing) {
                if (isPress) startGame();
            } else {
                if (isPress) handleJumpInput();
                else releaseJump();
            }
        }

        document.addEventListener('keydown', e => {
            if (!gameState.playing && e.code !== 'Space') return;
            keys[e.key] = true;
            if (e.code === 'Space') {
                e.preventDefault();
                handleStartOrJump(true); 
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.key] = false;
            if (e.code === 'Space') releaseJump();
        });
        
        function handleScreenClick() {
            if (!gameState.playing) startGame();
        }
        startScreen.addEventListener('click', handleScreenClick);
        gameOverScreen.addEventListener('click', handleScreenClick);
        startScreen.addEventListener('touchstart', (e) => { e.preventDefault(); handleScreenClick(); }, { passive: false });
        gameOverScreen.addEventListener('touchstart', (e) => { e.preventDefault(); handleScreenClick(); }, { passive: false });
        
        canvas.addEventListener('click', () => { if (!gameState.playing) startGame(); });
        canvas.addEventListener('touchstart', (e) => { if (!gameState.playing) { e.preventDefault(); startGame(); } }, { passive: false });
        
        const jumpButton = document.getElementById('jumpButton');
        const duckButton = document.getElementById('duckButton');
        const shootButton = document.getElementById('shootButton');

        function jumpPress(e) { e.preventDefault(); if (gameState.playing) mobileJumpActive = true; }
        function jumpRelease(e) { e.preventDefault(); if (gameState.playing) mobileJumpActive = false; }
        jumpButton.addEventListener('mousedown', jumpPress);
        jumpButton.addEventListener('touchstart', jumpPress, { passive: false });
        jumpButton.addEventListener('mouseup', jumpRelease);
        jumpButton.addEventListener('touchend', jumpRelease, { passive: false });

        function duckPress(e) { e.preventDefault(); if (gameState.playing) mobileDuckActive = true; }
        function duckRelease(e) { e.preventDefault(); if (gameState.playing) mobileDuckActive = false; }
        duckButton.addEventListener('mousedown', duckPress);
        duckButton.addEventListener('touchstart', duckPress, { passive: false });
        duckButton.addEventListener('mouseup', duckRelease);
        duckButton.addEventListener('touchend', duckRelease, { passive: false });

        function shootHandler(e) { e.preventDefault(); if (gameState.playing) mobileShootTrigger = true; }
        shootButton.addEventListener('click', shootHandler);
        shootButton.addEventListener('touchstart', shootHandler, { passive: false });

        gameLoop();
    </script>
</body>
</html>
